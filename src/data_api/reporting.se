# This software (Augur) allows buying and selling event outcomes in ethereum
# Copyright (C) 2015 Forecast Foundation OU
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful, #    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
# Any questions please contact joey@augur.net

extern controller: [lookup:[int256]:int256, checkWhitelist:[int256]:int256]

BRANCHES = self.controller.lookup('branches')
extern branches: [addCurrency:[int256,int256,int256,int256]:int256, addMarketToBranch:[int256,int256]:int256, disableCurrency:[int256,int256]:int256, getBaseReporters:[int256]:int256, getBranchByNum:[int256]:int256, getBranchCurrency:[int256,int256]:int256, getBranchWallet:[int256,int256]:int256, getBranches:[]:int256[], getBranchesStartingAt:[int256]:int256[], getCreationDate:[int256]:int256, getCurrencyActive:[int256,int256]:int256, getCurrencyByContract:[int256,int256]:int256, getCurrencyRate:[int256,int256]:int256, getEventForkedOver:[int256]:int256, getForkPeriod:[int256]:int256, getForkTime:[int256]:int256, getInitialBalance:[int256,int256,int256]:int256, getMarketIDsInBranch:[int256,int256,int256]:int256[], getMinTradingFee:[int256]:int256, getMostRecentChild:[int256]:int256, getNumBranches:[]:int256, getNumCurrencies:[int256]:int256, getNumMarketsBranch:[int256]:int256, getOracleOnly:[int256]:int256, getParent:[int256]:int256, getParentPeriod:[int256]:int256, getPeriodLength:[int256]:int256, getVotePeriod:[int256]:int256, incrementPeriod:[int256]:int256, initializeBranch:[int256,int256,int256,int256,int256,int256,int256,int256,int256]:int256, reactivateCurrency:[int256,int256]:int256, removeLastCurrency:[int256]:int256, replaceCurrency:[int256,int256,int256,int256,int256]:int256, setBaseReporters:[int256,int256]:int256, setEventForkedOver:[int256,int256]:int256, setForkPeriod:[int256]:int256, setInitialBalance:[int256,int256,int256,int256]:int256, setMostRecentChild:[int256,int256]:int256, updateCurrencyRate:[int256,int256,int256,int256]:int256, updateNumCurrencies:[int256,int256]:int256]

# todo note in final version should be actual repcontract address on the mainnet
REPCONTRACT = self.controller.lookup('repContract')
extern repContract: [allowance:[address,address]:uint256, approve:[address,uint256]:uint256, balanceOf:[address]:uint256, decimals:[]:uint256, getRidOfDustForLaunch:[]:int256, getSeeded:[]:uint256, name:[]:uint256, setSaleDistribution:[address[],uint256[]]:uint256, symbol:[]:uint256, totalSupply:[]:uint256, transfer:[address,uint256]:uint256, transferFrom:[address,address,uint256]:uint256]

inset('../macros/float.sem')
inset('../macros/refund.sem')

# Storage of all data associated with reporters
    # Reporting is a map of branch ID to branch details
    # activeRep is a map of reporter address to attorep
    # dormantRep is a map of reporter address to attorep. NOTE: address 0x0000000000000000000000000000000000000000 contains REP that needs to be redistributed
    # totalActiveRep is all of the active attorep in augur
    # totalDormantRep is all of the dormant attorep in augur (totalActiveRep + totalDormantRep is all REP in Augur)
    # numberReporters is the number of addresses that hold non-zero rep
    # reporterLocks is a map of reporter address to an array of events that is causing them to be locked and the number of events causing them to be locked.  If there are no events then the reporter is free to deactivate their rep.  If there are any locking events the reporter is unable to deactivate their REP.
data Reporting[](activeRep[], dormantRep[], totalActiveRep, totalDormantRep, numberReporters, reporterLocks[](events[], eventCount))

data controller

def init():
    self.controller = 0x0
    REPCONTRACT = self.controller.lookup('repContract')
    redistributionRep = REPCONTRACT.balanceOf(0x0000000000000000000000000000000000000000)
    self.Reporting[1010101].activeRep[0x0000000000000000000000000000000000000000] = 0
    self.Reporting[1010101].dormantRep[0x0000000000000000000000000000000000000000] = redistributionRep
    self.Reporting[1010101].totalActiveRep = 0
    self.Reporting[1010101].totalDormantRep = redistributionRep
    # TODO: figure out why address 0 counts as a reporter, feels like this should be `0`
    self.Reporting[1010101].numberReporters = 1
    self.Reporting[1010101].reporterLocks[0x0000000000000000000000000000000000000000].eventCount = 0

def getNumberOfEventsLockingReporter(branch, reporterAddress):
    return(self.Reporting[branch].reporterLocks[reporterAddress].eventCount)

def lockReporter(branch, reporterAddress, event):
    self.controller.checkWhitelist(msg.sender)
    self.Reporting[branch].reporterLocks[reporterAddress].events[event] = 1
    self.Reporting[branch].reporterLocks[reporterAddress].eventCount += 1
    return(1)

def unlockReporter(branch, reporterAddress, event):
    self.controller.checkWhitelist(msg.sender)
    if (self.Reporting[branch].reporterLocks[reporterAddress].events[event] == 0):
        throw()
    if (self.Reporting[branch].reporterLocks[reporterAddress].eventCount <= 0):
        throw() # if we are in this state things are _really_ broken
    self.Reporting[branch].reporterLocks[reporterAddress].events[event] = 0
    self.Reporting[branch].reporterLocks[reporterAddress].eventCount -= 1
    return(1)

def activateRep(branch, attorep):
    return(self.activateRepFor(branch, attorep, msg.sender))

def activateRepFor(branch, attorepToActivate, reporterAddress):
    self.controller.checkWhitelist(msg.sender)
    # CONSIDER: should people who are locked be prevented from activating rep?
    startingDormantRep = self.Reputation[branch].dormantRep[reporterAddress]
    startingActiveRep = self.Reputation[branch].activeRep[reporterAddress]
    self.Reputation[branch].dormantRep[reporterAddress] = safeSub(startingDormantRep, attorepToActivate)
    self.Reputation[branch].activeRep[reporterAddress] = safeAdd(startingActiveRep, attorepToActivate)
    return(1)

def deactivateRep(branch, attorep):
    return(self.deactivateRepFor(branch, attorep, msg.sender))

def deactivateRepFor(branch, attorepToDeactivate, reporterAddress):
    self.controller.checkWhitelist(msg.sender)
    if (reportedOnNonFinalRoundTwoEvent):
        throw()
    startingActiveRep = self.Reputation[branch].activeRep[reporterAddress]
    startingDormantRep = self.Reputation[branch].dormantRep[reporterAddress]
    self.Reputation[branch].activeRep[reporterAddress] = safeSub(startingActiveRep, attorepToDeactivate)
    self.Reputation[branch].dormantRep[reporterAddress] = safeAdd(startingDormantRep, attorepToDeactivate)
    return(1)

def getActiveRepBalance(branch, reporterAddress):
    return(self.Reporting[branch].activeRep[reporterAddress])

def getDormantRepBalance(branch, reporterAddress):
    return(self.Reporting[branch].dormantRep[reporterAddress])

def getTotalActiveRep(branch):
    return(self.Reporting[branch].totalActiveRep)

def getTotalDormantRep(branch):
    return(self.Reporting[branch].totalDormantRep)

def getTotalRep(branch):
    return(self.Reporting[branch].totalActiveRep + self.Reporting[branch].totalDormantRep)

# TODO: add an offset and a limit so the contract doesn't become unusable if there are many branches
# TODO: remove dependency on BRANCH here, instead take in an array of branches to get reputation for and leave it up to the caller to come up with that array, this also solves the above problem
def getReputation(reporterAddress):
    # TODO: figure out what this means for address 0x0000000000000000000000000000000000000000
    if (!address):
        address = msg.sender
    branchListCount = BRANCHES.getNumBranches()
    branches = array(2 * branchListCount)
    branchList = array(branchListCount)
    branchList = BRANCHES.getBranches(outitems = branchListCount)
    i = 0
    b = 0
    while(i < branchListCount):
        branch = branchList[i]
        balance = self.getActiveRepBalance(branch, reporterAddress)
        if(balance != 0):
            branches[b] = branch
            branches[b + 1] = balance
            b += 2
        i += 1
    return(branches: arr)

def getNumberReporters(branch):
    return(self.Reporting[branch].numberReporters)

# TODO: can this be renamed to "initializeBranch"?  Is that accurate?
# TODO: figure out if this function should take in parent branch and migrate over REP at address 0x0000000000000000000000000000000000000000
def setInitialReporters(branch):
    self.controller.checkWhitelist(msg.sender)
    # TODO: address 0 is a reporter?
    self.Reporting[branch].numberReporters = 1
    return(1)

# FIXME: sometimes when this is called, it is called with the event ID as `reporterAddress`, resulting in +1 reporter that will never report
def migrateReporterToNewBranch(originalBranch, newBranch, reporterAddress):
    self.controller.checkWhitelist(msg.sender)
    # TODO: figure out if it is intended that both active and dormant rep are moved
    # FIXME: calling this fully unlocks the sender as we aren't migrating event locks, is this OK?
    originalActiveRep = self.Reporting[originalBranch].activeRep[reporterAddress]
    originalDormantRep = self.Reporting[originalBranch].dormantRep[reporterAddress]
    self.Reporting[originalBranch].activeRep[reporterAddress] = 0
    self.Reporting[originalBranch].dormantRep[reporterAddress] = 0
    self.Reporting[newBranch].activeRep[reporterAddress] = originalActiveRep
    self.Reporting[newBranch].dormantRep[reporterAddress] = originalDormantRep
    self.Reporting[newBranch].totalActiveRep += originalActiveRep
    self.Reporting[newBranch].totalDormantRep += originalDormantRep
    # TODO: look for exploit around multiple callso of this function that could result in adding the same reporter multiple times
    self.Reporting[branch].numberReporters += 1
    return(1)

def penalizeReporter(branch, reporterAddress, attorep):
    self.controller.checkWhitelist(msg.sender)
    startingActiveRep = self.Reporting[branch].activeRep[reporterAddress]
    self.Reporting[branch].activeRep[reporterAddress] = safeSub(startingActiveRep, attorep)
    self.Reporting[branch].activeRep[0x0000000000000000000000000000000000000000] += attorep
    return(1)

def transferRep(branch, destinationReporterAddress, attorep):
    return(self.transferRepFrom(branch, msg.sender, destinationReporterAddress, attorep))

def transferRepFrom(branch, sourceReporterAddress, destinationReporterAddress, attorep):
    self.controller.checkWhitelist(msg.sender)
    startingSourceDormantRep = self.Reporting[branch].dormantRep[sourceReporterAddress]
    self.Reporting[branch].dormantRep[sourceReporterAddress] = safeSub(startingSourceDormantRep, attorep)
    self.Reporting[branch].dormantRep[destinationReporterAddress] += attorep
    return(1)

def claimInitialRepFromRepContract():
    # TODO: figure out if there are any problems with claiming rep after the first branch
    branch = 1010101
    sender = msg.sender
    dormantRep = REPCONTRACT.balanceOf(sender)
    if(!dormantRep):
        throw()
    if(dormantRep != REPCONTRACT.allowance(sender, self)):
        throw()
    if(!REPCONTRACT.transferFrom(sender, 0x0000000000000000000000000000000000000000, dormantRep)):
        throw()
    self.Reporting[branch].dormantRep[sender] += dormantRep
    self.Reporting[branch].totalDormantRep += dormantRep
    # FIXME: attack vector: put 1 attorep in an account, claim it, put one more attorep in the account, claim it -- numberReporters goes up with each call
    self.Reporting[branch].numberReporters += 1
    return(1)

def setController(newController):
    if(msg.sender != self.controller):
        throw()
    self.controller = newController
    return(1)

def suicideFunds(to):
    if(msg.sender != self.controller):
        throw()
    suicide(to)
